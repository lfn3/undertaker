(ns undertaker.proto
  (:require [clojure.spec.alpha :as s]
            [undertaker.bytes :as bytes]
            [undertaker.debug :as debug]))

(s/def ::interval-name string?)
(s/def ::interval-parent-id (s/or :nil nil? :id int?))
(s/def ::interval-id int?)
(s/def ::interval-start (s/or :pos pos-int? :zero zero?))
(s/def ::hint-applies-to #{::immediate-children-of})
(s/def ::hint-names #{::unique})
(s/def ::hint (s/tuple ::hint-applies-to ::hint-names ::interval-id))
(s/def ::hints (s/coll-of ::hint))

(s/def ::wip-interval (s/keys :req [::interval-name ::interval-id ::interval-start ::hints ::interval-parent-id]))

(s/def ::interval-end (s/or :pos pos-int? :zero zero?))
(s/def ::generated-value (s/with-gen any? #(s/gen nil?)))
(s/def ::mapped-bytes ::bytes/bytes)

(s/def ::interval (s/keys :req [::interval-name
                                ::interval-id
                                ::interval-start
                                ::interval-end
                                ::generated-value
                                ::mapped-bytes
                                ::interval-parent-id
                                ::hints]))

(s/def ::interval-stack (s/coll-of ::wip-interval))
(s/def ::completed-intervals (s/coll-of ::interval))

(s/def ::interval-id-counter ::interval-id)
(s/def ::source-state (s/keys :req [::interval-id-counter
                                    ::interval-stack
                                    ::completed-intervals
                                    ::bytes/bytes]))

(defn source-state-validator [state]
  (let [byte-counter (count (::bytes/bytes state))]
    (when-not (s/valid? ::source-state state)
      (throw (debug/internal-exception "Did not match spec" {:explained (s/explain ::source-state state)})))

    (when-let [overrunning-intervals (->> state
                                          ::completed-intervals
                                          (filter #(< byte-counter (::interval-start %1)))
                                          (seq))]
      (throw (debug/internal-exception "Intervals overran generated bytes" {:intervals    overrunning-intervals
                                                                            :byte-counter byte-counter})))
    (when-let [overrunning-intervals (->> state
                                          ::completed-intervals
                                          (filter #(< byte-counter (::interval-end %1)))
                                          (seq))]
      (throw (debug/internal-exception "Intervals overran generated bytes" {:intervals    overrunning-intervals
                                                                            :byte-counter byte-counter})))
    true))

(defprotocol ByteArraySource
  (get-bytes [this ranges skip]))

(defprotocol Interval
  (push-interval [this interval-name hints])
  (pop-interval [this interval-id generated-value])
  (get-intervals [this])
  (get-wip-intervals [this]))

(defprotocol Recall
  "Allows you to get the sequence of bytes this source of randomness has emitted since the last reset."
  (get-sourced-bytes [this])
  (reset [this]))
